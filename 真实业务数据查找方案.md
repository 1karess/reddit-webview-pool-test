# 真实业务数据查找方案

## 核心问题

**如果真实业务中没有重要数据，不清理只是设计缺陷，不是实际漏洞。**

我们需要找到 Reddit 真实业务中到底存了什么。

---

## 为什么 window.name 是空的？

### 代码分析

**文件**: `l.java:119-123`

```java
if (!nVar.f79141s || nVar.f79142t) {
    loadUrl(nVar.f79123a);  // 直接加载 URL，不设置 window.name
    return;
}
// 只有在这个条件不满足时，才会设置 window.name
loadDataWithBaseURL(null, kotlin.text.q.q("\n          <html>\n          <body>\n          <script>\n              window.name = " + JSONObject.quote(bridgeContext) + ";\n              window.location.replace(\"" + this.f79105b.f79123a + "\");\n          </script>\n          </body>\n          </html>\n      "), "text/html", "UTF-8", null);
```

**条件分析**：
- `f79141s` - 可能是 `isWindowNameJsInjectionFixEnabled`（功能开关）
- `f79142t` - 可能是另一个功能开关
- **如果 `!f79141s || f79142t` 为 true，就不会设置 window.name**

**可能的原因**：
1. 功能开关被禁用了（`f79141s = false`）
2. 或者使用了不同的代码路径（`f79142t = true`）
3. 或者不在真实的 DevPlatform 页面中

---

## 真实业务数据查找方法

### 方法 1：直接读取 WebView 存储目录（最直接）

#### 需要 root 或 debug 版本

```bash
# 读取 localStorage 数据库
adb shell "run-as com.reddit.frontpage cat /data/data/com.reddit.frontpage/app_webview/Default/Local\ Storage/leveldb/*" 2>/dev/null | strings | grep -E "(webbitToken|signedRequestContext|postData|user|token|auth)" | head -20

# 读取 Cookie 数据库
adb shell "run-as com.reddit.frontpage cat /data/data/com.reddit.frontpage/app_webview/Default/Cookies" 2>/dev/null | strings | grep -E "(reddit|auth|token|session)" | head -20

# 列出所有存储文件
adb shell "run-as com.reddit.frontpage ls -la /data/data/com.reddit.frontpage/app_webview/Default/" 2>/dev/null
```

**限制**：需要 root 或 debug 版本，普通设备可能无法访问。

---

### 方法 2：在真实 DevPlatform 页面中执行检测脚本

#### 步骤

1. **找到真实的 DevPlatform 页面**
   - 某些包含交互式内容的帖子
   - 某些设置页面
   - 某些嵌入式内容

2. **如果页面支持控制台/开发者工具**：
   - 打开控制台
   - 执行检测脚本

3. **如果页面不支持控制台**：
   - 想办法注入检测脚本（可能需要 Frida 或其他工具）

---

### 方法 3：通过 adb logcat 监控

#### 监控 WebView 活动

```bash
adb logcat | grep -E "(WebView|webview|localStorage|sessionStorage|Cookie|bridgeContext|window\.name)" | tee webview_activity.log
```

**然后**：
1. 在 Reddit App 中打开真实的 DevPlatform 页面
2. 观察日志，看是否有存储操作

---

### 方法 4：分析 Reddit 的 JavaScript 代码

#### 查找 DevPlatform 页面的 JavaScript

1. **找到 DevPlatform 页面的实际 URL**
   - 可能是 `https://devvit.reddit.com/...` 或其他域名

2. **访问该 URL，查看页面源代码**
   - 看是否有操作 localStorage/sessionStorage 的代码
   - 看是否有读取 window.name 的代码

3. **分析这些代码，看存储了什么数据**

---

## 关键检查点

### 1. 检查是否有任何存储操作

**在真实 DevPlatform 页面中执行**：
```javascript
// 检查所有可能的存储
console.log('localStorage:', localStorage.length, 'items');
for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    console.log(key, ':', localStorage.getItem(key));
}

console.log('sessionStorage:', sessionStorage.length, 'items');
for (let i = 0; i < sessionStorage.length; i++) {
    const key = sessionStorage.key(i);
    console.log(key, ':', sessionStorage.getItem(key));
}

console.log('Cookies:', document.cookie);

console.log('window.name:', window.name);
```

### 2. 检查 IndexedDB

```javascript
if ('indexedDB' in window) {
    indexedDB.databases().then(databases => {
        console.log('IndexedDB databases:', databases);
    });
}
```

### 3. 监控存储操作

```javascript
// Hook localStorage
const originalSetItem = localStorage.setItem;
localStorage.setItem = function(key, value) {
    console.log('localStorage.setItem:', key, '=', value);
    return originalSetItem.apply(this, arguments);
};

// Hook sessionStorage
const originalSessionSetItem = sessionStorage.setItem;
sessionStorage.setItem = function(key, value) {
    console.log('sessionStorage.setItem:', key, '=', value);
    return originalSessionSetItem.apply(this, arguments);
};
```

---

## 如果确实什么都没存

### 结论

如果经过以上所有方法检测，发现：
- ✅ localStorage 为空
- ✅ sessionStorage 为空
- ✅ Cookie 中没有敏感数据（只有 HttpOnly Cookie）
- ✅ window.name 为空或只包含非敏感信息
- ✅ IndexedDB 为空

**那么**：
- 这是一个**设计缺陷**，不是**实际漏洞**
- 报告应该写成："WebView Pool 缺少账号级存储清理机制（设计缺陷）"
- 说明：这是一个潜在风险，需要修复以防止未来出现问题
- **不是**："跨账号数据泄露漏洞"

---

## 下一步行动

1. **尝试方法 1**（如果设备支持 root/debug）
2. **尝试方法 2**（在真实 DevPlatform 页面中检测）
3. **尝试方法 3**（通过 logcat 监控）
4. **根据实际检测结果，确定风险等级**

**如果确实什么都没存，那就承认这只是设计缺陷，不是实际漏洞。**
